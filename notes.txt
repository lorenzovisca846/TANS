DA RISCRIVERE IN LATEX

\\\ per i codici
<R> per il terminale ROOT

========================================
Esercitazione 1: gestione di input-output
File di riferimento: ioexample/ioexample.C     ioexample/input.dat

    Con l'estensione .C si indica convenzionalmente una macro ROOT.
    
----Utilizzo della libreria <fstream>
    Dichiarazione file input:

        \\\  ifstream in(name);
    
        in = nome della variabile associata al file
        name = string contenente il nome del file, ad es. "input.dat"

    Dichiarazione file output:

        \\\ ofstream out(name);

        out = nome della variabile associata al file
        name = string contenente il nome del file, ad es. "input.dat"

    Per gestione della memoria ricordarsi di chiudere i file dopo il loro utilizzo:

        \\\ in.close();
        \\\ out.close();

    La macro viene caricata in ROOT:

        <R> .L ioexample.c
    
    E per utilizzarla viene chiamata con i giusti argomenti, che vengono mostrati premendo tab una volta scritta la funzione. Si consideri input.dat come file input, pippo.dat come file output

        <R> ioexample("input.dat","pippo.dat")


========================================
Esercitazione 2: creazione istogrammi, creazione di file ROOT
File di riferimento: ioexample2/ioexample2.C     ioexample2/dati0.dat     ioexample2/pippo.root

----Passaggio delle variabili per riferimento
    In ioexample.C abbiamo passato alla macro il file "by value":

        \\\ void ioexample(string fimpName, string foupName)

    In questo modo viene creata una copia della variabile all'interno della macro, senza nessun effetto sull'eventuale programma chiamante.
    In alternativa si può passare la variabile "by reference" ovvero tramite un puntatore che punta alla variabile originale. In questo modo qualunque sua modifica ha effetto anche sul programma chiamante:

        \\\ void ioexample2(string& fimpName, string& histName)

    L'utilità del passaggio by reference è che non si utilizza memoria extra per creare copie.
    Per evitare modifiche accidentali è possibile definire le variabili passate come "const", in questo modo se si prova a modificarle il compilatore segna errore.

        \\\ void ioexample2(const string& fimpName, const string& histName)


----Creazione dell'istogramma

    La classe di ROOT TH1D gestisce istogrammi di valori double. Per creare un istogramma la sintassi è:

        \\\ TH1D isto("hist","Istogramma",100,-7,7);

        isto = nome della variabile
        hist = nome con cui la gestione oggetti di ROOT salva l'istogramma
        Istogramma = titolo dell'istogramma
        100 = numero di bin
        -7,7 = estremo inferiore, estremo superiore

    Questa dichiarazione crea problemi: innanzitutto l'istogramma viene salvato nella stack memory, più piccola di quella heap, inoltre una volta chiuso lo scope (ovvero quando l'esecuzione raggiunge "}") l'oggetto viene distrutto
    Ciò che si fa è quindi dichiarare la variabile in modo dinamico:

        \\\ TH1D* isto = new TH1D("hist","Istogramma",100,-7,7);

    In questo modo "isto" è un puntatore all'oggetto istogramma creato. Ad essere distrutto out of scope è quindi il puntatore, non l'oggetto.
    Scrivendo un codice è quindi in linea di massima necessario cancellare gli oggetti con:

        \\\ delete isto;

    Oppure si continua a riempire la heap memory rischiando un overflow chiamato "memory leak".
    In realtà il comando delete non deve essere utilizzato per oggetti ROOT, perché è ROOT che gestisce gli oggetti e la loro eliminazione. Se provassimo a distruggere un oggetto ROOT (TObject) con delete, quando ROOT prova a fare lo stesso non trova più l'oggetto da cancellare e va in crash.


----Riempimento dell'istogramma

    Per inserire un valore double x dentro un istogramma si utilizza il comando Fill(x). La sintassi è diversa a seconda di come è stato dichiarato l'istogramma, in generale infatti vale che:
    - quando si utilizza un oggetto, l'accesso alle sue member functions avviene tramite .

        \\\ TH1D isto("hist","Istogramma",100,-7,7);
        \\\ double x = 3.14;
        \\\ isto.Fill(x);

    - quando si utilizza un puntatore ad un oggetto, l'accesso alle sue member functions avviene tramite ->

        \\\ TH1D* isto = new TH1D("hist","Istogramma",100,-7,7);
        \\\ double x = 3.14;
        \\\ isto->Fill(x);

    Una volta riempito l'istogramma, esso viene disegnato con il comando Draw();


----Creazione di un file ROOT

    Gli oggetti ROOT possono essere salvati dentro oggetti della classe TFile. Ad esempio, per salvare l'istogramma appena creato:

        \\\ TFile file(histName.c_str(), "recreate");
        \\\ hist->Write();
        \\\ file.Close();
    
        histName.c_str() crea un array di char (richiesto dal costruttore file) contenente il nome scelto per il file di output chiamando la macro
        "recreate" vuol dire che crea il file se non esiste e lo sovrascrive se esiste
        Write() scrive l'istogramma nella working directory attiva, in questo caso nel file appena creato
        Close() chiude il file. Si noti che avendo definito il file come oggetto, la member function viene richiamata con . invece che con ->

    La macro ioexample2.C può essere chiamata dando in input dati.dat e creando il root file di output pippo.root:

        <R> .L ioexample2.c
        <R> ioexample2("dati0.dat", "pippo.root");


========================================
Esercitazione 3: gestione alternativa dei file ROOT
File di riferimento: ioexample2/ioexbis.C     ioexample2/dati0.dat     ioexample2/pippo.root

----Salvataggio di eventuali oggetti multipli in un file ROOT

    Si consideri l'eventualità di voler salvare più oggetti in un TFile, si vuole evitare di ripetere oggetto->Write() per ogni file.
    A tale scopo è sufficiente dichiarare il file prima degli oggetti, in questo modo la working directory degli oggetti è già il file creato.
    Dopodiché una volta effettuate tutte le operazioni sugli oggetti è sufficiente utilizzare la member function di TFile Write() per salvare tutti gli oggetti in un colpo solo

        \\\ File file(histName.c_str(), "recreate");
        \\\ TH1D* hist = new TH1D("hist", "Istogramma", 100, -7., 7.);
        \\\ double x = 3.14;
        \\\ hist->Fill(x);
        \\\ hist->Draw();
        \\\ file.Write();
        \\\ file.close();

    NOTA: se l'istogramma viene creato nella stack il comando Draw() non è sufficiente, ma la funzione corretta è:

        \\\ hist->DrawCopy();

    In questo modo quando si arriva al termine dello scope l'istogramma non si distrugge, poiché DrawCopy ne crea una copia nell'heap che non viene distrutta.


========================================
Esercitazione 4: dichiarazione dell'istogramma con estremi variabili
File di riferimento: ioexample2/esercizio1_v1.C     ioexample2/esercizio1_v2.C     ioexample2/dati.dat     ioexample2/pippo.root

----Lettura di un numero variabile di dati in un intervallo non noto

    Per non dichiarare a priori l'intervallo dell'istogramma ci sono due approcci possibili:
    
    1) leggere due volte il file: la prima volta si leggono tutti i numeri per identificarne min e max, che vengono utilizzati come estremi.
        VANTAGGI: risparmio di memoria, poiché non viene creata una copia dei dati
        SVANTAGGI: maggiore tempo di esecuzione, perché la lettura-scrittura di file rallenta notevolmente le operazioni
    
    2) leggere il file identificando min e max, nel frattempo tutti i dati vengono salvati in un vettore poi utilizzato per riempire l'istogramma
        VANTAGGI: esecuzione più veloce
        SVANTAGGI: si crea una copia dei dati in memoria, problematico quando l'array è molto lungo
        
        La creazione dell'array può essere fatta in due modi:
        1) STATICO: richiede di sapere a priori il numero di elementi, oppure di inizializzare l'array con una dimensione sicuramente maggiore del numero di dati (sconsigliato)
        2) DINAMICO: si utilizza un oggetto della classe vector, non richiede la conoscenza a priori del numero di elementi


----Opzioni di loading delle macro

    Si può compilare la macro utilizzando il compilatore di ROOT:

        <R> .L esercizio1_v1.C++

    Il comando crea uno shared object precompilato. Questa opzione fa la differenza quando si utilizzano codici pesanti: la compilazione è più lenta, ma dopo averla effettuata una volta l'esecuzione è molto più veloce rispetto all'interpretazione.
    Si può anche utilizzare l'opzione seguente:

        <R> .L esercizio1_v1.C+

    Utilizzando un solo + la macro viene compilata, ma se la shared library esiste ed è aggiornata all'ultima modifica essa non viene ricompilata, risparmiando tempo.
    Forzare la ricompilazione completa con "++" è utile ad esempio se si fa un upgrade del compilatore.


----Apertura dei file ROOT

    Una volta creato un TFile di output (ad esempio pippo.root) ci sono diversi modi per visualizzarlo:

    1) aprire il browser interattivo di ROOT per vedere il file ed effettuare tutte le operazioni possibili sulla finestra:

        <R> new TBrowser();

        In questo modo si apre una finestra interattiva in cui si può navigare tra i file

    2) chiamare il file da un'altra macro:

            \\\ TFile *miofile = new TFile("pippo.root");

            miofile = nome scelto per la variabile

        Per recuperare l'istogramma si utilizza la member function Get() della classe TObject castando l'oggetto chiamato a TH1D (ovvero "forzandone" il tipo)

            \\\ *hh = (TH1D*) miofile->Get("hist");

            hh = nome della variabile puntatore all'istogramma nella nuova macro
            hist = nome dell'istogramma salvato in origine
            NOTA: hist è il nome riconosciuto da ROOT (il primo oggetto passato al costruttore dell'istogramma), non il nome della variabile nella vecchia macro

        A questo punto si può utilizzare l'istogramma ad esempio con hh->Draw();
        Il problema è che l'istogramma è ancora linkato a miiofile, quindi se si chiude il file con miofile->Close(); si perde accesso all'istogramma.
        Per evitare il problema si può cambiare la directory dell'istogramma per scollegarlo dal file prima che quest'ultimo venga chiuso:

            \\\ hh->SetDirectory(NULL);
            \\\ miofile->Close();
            \\\ delete miofile;